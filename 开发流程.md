# SceneDelegate
0. 设置版本iOS 14， 支持竖屏
1. 删除初始化相关配置（SB,info,ViewController.h .m）
2. 设置SceneDelegate 自定义初始化VC
3. 禁止横屏 https://www.jianshu.com/p/848ec0f65d33

# JFΜainViewController
1. JFΜainViewController继承
⚠️找图片资源：https://shape.so/app/icons/category/object 
图片资源命名规范 setting_tabBarItem_selected@3x
2. tabbar tintColor
3. 设置代理
4.0 创建添加子控制器（包装上nav，添加UITabBarController 的子控制器中)
4.1 子控制器设置（标题，tabBarItem.image, view的背景）

# HomeViewController
⚠️颜色设置，选sRGB  [UIColor colorWithRed:211 / 255.0 green:251 / 255.0 blue:226 / 255.0 alpha:1]; 要除255.0
1.0 安装cocoPods pod cd 目录; pod init; 
1.1 pod 'Masonry'  https://github.com/SnapKit/Masonry
However if you're using Swift in your project, we recommend using SnapKit as it provides better type safety with a simpler API.
1.2 pod install(接下来就使用LieChives.xcworkspace)
1.3 #import "Masonry.h"

⚠️遇到了报错
Thread 1: "couldn't find a common superview for <UIView: 0x13d006620; frame = (0 0; 0 0); layer = <CALayer: 0x600000c2cac0>> and <UIView: 0x13ae06720; frame = (0 0; 390 844); autoresize = W+H; layer = <CALayer: 0x600000c589c0>>"
原因：在使用masonry库时，必须要将当前的视图加入到其上一层视图中才可以使用masonry约束。

2.0.0 setupSubViews

2.0.1 创建并设置 大的presentTimeBackgroundView（布局，测试颜色）
2.0.2 创建并设置 时间view容纳器 presentTimeView（布局，颜色）
2.0.3 创建并设置 次数容纳器 TimesView（布局，颜色）

2.1.0 在 大的presentTimeBackgroundView 里面设置：
2.1.1 “日” 标签创建，设置富文本（大小，居中），添加子view,设置布局
2.1.2 "月年" 标签创建，设置富文本（大小，居中），添加子view,设置布局

2.2.0 在 timesView里面设置：次数标签，设置富文本（大小，居中），添加子view,设置布局
2.2.1 NSDate获取现在时间，设置日期格式，截取日期字符串，添加到日期lbl中
⚠️发现时间没有显示，显示了之前设置的初始时间：原因：在设置文字之后再设置文字的富文本（反之文字不会变化）

3. 进行代码封装（JFPresentTimeBackgroundView.m)

# JFPresentTimeBackgroundView
1. 添加控件属性
2. 懒加载：
⚠️懒加载：卡在if判断，断点不动：
之前：写成    if(!self.presentTimeBackgroundView){
断点 po 不出来 self.presentTimeBackgroundView
只显示self
改为：    if(!_presentTimeBackgroundView){
显示self 和 _presentTimeBackgroundView 值
首先使用self.a会调用getter/setter方法，而_a并不会调用getter/setter方法,它是直接访问实例变量并赋值。
https://www.jianshu.com/p/426eb6e4f6ac?nomobile=yes

3. 在initWithFrame:(CGRect)frame进行控件设置 
setupSubViews 添加子控件 添加自动布局
https://www.jianshu.com/p/b58da80ddee7

4.0 回到JFHomeViewController：
4.1 添加presentTimeBackgroundView属性 懒加载属性
4.2 在setupSubViews设置 添加子视图，添加自动布局

# JFRoomsBackgroundView
1. 添加控件属性
2. 懒加载：四个房间按钮，设置图片

⚠️设置按钮的图片拉伸效果：
    /*
     UIViewContentModeScaleToFill,
     UIViewContentModeScaleAspectFill,     // contents scaled to fill with fixed aspect. some portion of content may be clipped.
     UIViewContentModeRedraw,              // redraw on bounds change (calls -setNeedsDisplay)
     
     
     UIViewContentModeTop,
     UIViewContentModeBottom,
     UIViewContentModeLeft,
     UIViewContentModeRight,
     UIViewContentModeTopLeft,
     UIViewContentModeTopRight,
     UIViewContentModeBottomLeft,
     UIViewContentModeBottomRight,
     */
             _bedroomBtn.imageView.contentMode = UIViewContentModeScaleAspectFill;
     
3. 在initWithFrame:(CGRect)frame进行控件设置 
setupSubViews 添加子控件 添加自动布局
4. 增加四个房间相应的标签属性 懒加载标签 （设置标签 富文本text）
5. setupSubViews 添加标签（到四个房间按钮上） 添加自动布局

⚠️在按钮里面添加标签，点击标签也点击按钮（不影响按钮的点击）

5. 将四个房间按钮移到.h 属性

# JFHomeViewController
1. setupSubViews里面增加    [self addRoomsBtnClick];
2.     [self addRoomsBtnClick]; 添加房间按钮的监听方法
3. 设置出相应的点击方法
4. 点击方法中
    [self.navigationController pushViewController:[JFKitchenTableViewController new] animated:YES];
5. 创建4个房间tableCV

1. JFMainViewController：nav.navigationBar.tintColor = [UIColor systemGreenColor];
设置navigationgBar的渲染颜色
2. 设置四个房间子控制器的    self.navigationItem.title = @"厨房";
3. LieChives.xcdatamodeld 添加四个房间模型 和 相关属性（布尔值）
4. 设置手动版 Data Model inspector -> Codegen -> Manual/None，Create NSManagedobject Subclass. 
5. 建立tools文件夹，进行文件整理
6. 完成JFCoreDataManager
7.JFKitchenTableViewController 里面测试数据库的储存
8. 测试数据库的查找
9.cell的数据源方法设置： kitchenPartArr记录cell的cell.textLabel.text, 
    cell.textLabel.text = self.kitchenPartArr[indexPath.row];
        cell.tintColor = [UIColor systemGreenColor];

    
    ⚠️"unable to dequeue a cell with identifier kitchenCell - must register a nib or a class for the identifier or connect a prototype cell in a storyboard"
https://blog.csdn.net/args_/article/details/51910930
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
    
10.打算使用    cell.accessoryType = UITableViewCellAccessoryCheckmark;
来表示对勾
11.获取当前点击的cell
https://www.cnblogs.com/hero11223/p/7986178.html

12.Kitchen+CoreDataProperties.h：
⚠️@property (nullable, nonatomic, retain) NSNumber *chuGui;
⚠️别用布尔值，都改成NSNumber，把LieChives.xcdatamodeld 改成integer64
coredata不支持布尔值，会有各种错误
⚠️+ (NSFetchRequest<Kitchen *> *)fetchRequest NS_SWIFT_NAME(fetchRequest());
使用：
    NSArray *temp = [[JFCoreDataManager sharedManager].managerContext executeFetchRequest:[Kitchen fetchRequest] error:nil];

    //打印结果集
    for (Kitchen *kitchen  in temp) {
        NSLog(@"%@--%@---%@---%@ 一共有多少个记录%lu",kitchen.gongZuoTai,kitchen.zaoTai,kitchen.chuGui,kitchen.shuiChi,temp.count);
        //⚠️NSNumber 打印%@
    }
    
    
    
    思路：根据text识别cell，在cell里面判断是否点击使用coredata模型（NSNumber, 为0，为空 没有做这项，否则就打勾
    NSArray *temp = [[JFCoreDataManager sharedManager].managerContext executeFetchRequest:[Kitchen fetchRequest] error:nil];
每次都从数据库里面获取，写入,读取


⚠️第一次在数据库中写入数据要（insertNewObject）
  Kitchen *kitchen = [NSEntityDescription insertNewObjectForEntityForName:@"Kitchen" inManagedObjectContext:[JFCoreDataManager sharedManager].managerContext];
之后更新数据的话用：
    NSArray *temp = [[JFCoreDataManager sharedManager].managerContext executeFetchRequest:[Kitchen fetchRequest] error:nil];
https://www.jianshu.com/p/332cba029b95

13. JFKitchenTableViewController：

14. @property (nonatomic, strong) Kitchen *kitchen;

15. kitchen 懒加载， 获取数据库模型数据，直接模型赋值

16. viewDidLoad:
    [self initKitchenData]; 创建一次数据库

如何只创建一次数据库 Kitchen？
    //先获取一下
    NSArray *temp = [[JFCoreDataManager sharedManager].managerContext executeFetchRequest:[Kitchen fetchRequest] error:nil];
    if(temp.count == 0){
    //创建数据库
    }else{
    return;
}

17. cellForRowAtIndexPath
    //打对勾了缓存了，就打对勾
判断cell.textLabel.text（来确定是哪个cell），再在里面判断模型是否（0还是1），来设置打勾状态

18. - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
点击cell：
获取点击cell
判断cell.textLabel.text（来确定是哪个cell），再在里面判断模型是否（0还是1），来设置相反的值（0 or 1)
更新数据库，保存（之前这里忘了，找了好久）
https://www.jianshu.com/p/332cba029b95 （之前就是没好好看这个）


怎么统计完成周期？
每一个房间都完成，总周期+1
一个房间完成，房间完成周期+1
统计每个房间是否完成，如果完成总周期+1

一个房间完成，房间完成周期+1？
0 与 1 的区分
在页面即将退出的时候判断
   
1. LieChives.xcdatamodeld 增加finishedCount属性 integer64
2. 更改模型文件两个，增加@property @dynamic
3. initKitchenData 增加初始化
4. - (void)viewWillDisappear:(BOOL)animated{
在界面即将消失里面判断，用户一般都是离开的时候就差不多确定了,而且最后统一判断，就不在选中row多次判断了
判断厨房的四个部分是否都完成，更新finishedCount（是不是都更新一下，以防万一），保存数据

将剩下三个都复制粘贴更改厨房上述JFKitchenTableViewController, 以及厨房模型
1. 更改LieChives.xcdatamodeld 的属性为integer64, 增加finishedCount属性
2. 文件目录 新建文件夹进行排序
3. .h 更改属性，增加finishedCount
4. livingroomVC.m 完成
5. bedroomVC.m 完成
6. bathroomVC.m wanc

1. 写完 Tips.plist
2. 新建tips.m .h 并写上初始化plist模型的方法
3. JFTipsVC 导入头文件，进行plist模型数组的懒加载
4. VC 数据源方法设置包括 组标题
产生问题：不换行
